```markdown
# Algorithms-and-Data-Structure

Репозиторий, где реализована часть  алгоритмов и структур данных в рамках курса АИСД в МФТИ. Проект полностью написан на [C++](https://isocpp.org/).

## Основные моменты

- **Курс АИСД в МФТИ:** Все алгоритмы и структуры данных были разработаны в рамках курса Алгоритмы и Структуры Данных (АИСД) в МФТИ.
- **Язык реализации:** Проект полностью реализован на [C++](https://isocpp.org/).

## Алгоритмы

В этом разделе представлены реализации различных алгоритмов, включая:

- **Сортировки:**  
  QuickSort, MergeSort, HeapSort, BubbleSort и другие.

- **Поисковые алгоритмы:**  
  Линейный и бинарный поиск.

- **Графовые алгоритмы:**  
  Ниже приведены описания алгоритмов, реализованных для обработки графов:
  
  - **DFS (Поиск в глубину):**  
    Алгоритм обхода графа, который начинает с исходной вершины и рекурсивно исследует как можно глубже по каждому ответвлению перед возвратом назад. Применяется для обхода, поиска компонентов связности и обнаружения циклов.
  
  - **BFS (Поиск в ширину):**  
    Алгоритм обхода графа, который исследует все соседние вершины перед переходом к следующему уровню. Идеален для нахождения кратчайшего пути в ненагруженных графах.
  
  - **Алгоритмы поиска кратчайшего пути:**  
    Данная группа алгоритмов применяется для нахождения оптимальных маршрутов между вершинами графа. Если в проекте реализованы конкретные варианты (например, алгоритм Дейкстры или Беллмана-Форда), они входят в эту категорию, однако здесь приводится общий термин «алгоритмы поиска кратчайшего пути».
  
  - **Алгоритм Крускала:**  
    Используется для нахождения минимального остовного дерева (МОД) в графе. Алгоритм работает, сортируя рёбра по весу и постепенно добавляя их в остовное дерево, избегая циклов.
  
  - **Алгоритм Прима:**  
    Другой алгоритм построения минимального остовного дерева. Начинается с произвольной вершины и расширяет дерево, добавляя к нему минимальное ребро, которое соединяет вершину, уже являющуюся частью дерева, с новой вершиной.
  
- **Динамическое программирование:**  
  Примеры: Knapsack, Longest Common Subsequence и др.

- **Жадные алгоритмы:**  
  Примеры: задачи оптимизации, покрытие множества и др.

## Структуры данных

Здесь вы найдёте реализации всех ключевых структур данных:

- **Линейные структуры:**
  - Массивы
  - Векторы ([std::vector](https://en.cppreference.com/w/cpp/container/vector))
  - Связные списки (односвязные и двусвязные)
  - Стеки ([std::stack](https://en.cppreference.com/w/cpp/container/stack))
  - Очереди и двусторонние очереди ([std::queue](https://en.cppreference.com/w/cpp/container/queue), [std::deque](https://en.cppreference.com/w/cpp/container/deque))

- **Деревья:**
  - Двоичные деревья
  - Двоичные деревья поиска (BST)
  - Сбалансированные деревья (AVL)
  - SPLAY дерево

- **Графы:**
  - Структуры для представления графов (матрицы смежности, списки смежности и др.), используемые для реализации графовых алгоритмов.

- **Хеш-структуры:**
  - Хеш-таблицы ([std::unordered_map](https://en.cppreference.com/w/cpp/container/unordered_map))
  - Хеш-множества ([std::unordered_set](https://en.cppreference.com/w/cpp/container/unordered_set))

- **Ассоциативные структуры:**
  - Множества ([std::set](https://en.cppreference.com/w/cpp/container/set))
  - Отображения ([std::map](https://en.cppreference.com/w/cpp/container/map))

- **Другие структуры:**
  - Кучи (мин-куча, макс-куча)
  - Динамические массивы
  - Буферы циклической очереди
  - Vector, list, forward list
```
